import pandas as pd
import numpy as np

class LabelGenerator:
    """
    LabelGenerator creates future-trend labels for time-series data
    and aligns them with lookback windows for supervised learning.

    target_feature : str Column name to predict (e.g., 'close').
    trend_length : int Number of future steps to consider for trend labeling.
    lookback_period : int Number of past steps (window size) used for each sample.

    label_column : str Name of the generated label column.
    datetime_col : str Expected datetime column in input data.
    """

    def __init__(self, target_feature: str, trend_length: int, window_size: int):
        self.target_feature: str = target_feature
        self.trend_length: int = trend_length
        self.window_size: int = window_size

        self.label_column: str = 'label'

    def get_labeled_feature_data(self, time_series: pd.DataFrame) -> pd.DataFrame:
        """
        Add future-trend labels to the time-series DataFrame.

        Labels are binary (1 if future >= current, 0 otherwise), and
        rows without complete future data are removed.

        time_series : pd.DataFrame Input DataFrame containing features, including datetime and the target.

        return: DataFrame with a new `label` column and datetime index.
        """
        self._validate_feature_data(time_series)

        feature_data = time_series.copy()

        feature_data[self.label_column] = self._future_trend(feature_data[self.target_feature], periods=self.trend_length)

        feature_data = feature_data.iloc[:-self.trend_length]
        feature_data = feature_data.dropna()

        return feature_data

    def get_window_aligned_labels(self, feature_data: pd.DataFrame) -> np.ndarray:
        """
        Return label array aligned with lookback window sequences.

        feature_data : pd.DataFrame DataFrame with a `label` column generated by `get_labeled_feature_data`.

        return: Aligned 1D array of labels corresponding to windowed feature sequences.
        """
        self._validate_label_column(feature_data)
        labels = feature_data[self.label_column].values
        return self._align_labels(labels)

    def get_aligned_features(self, feature_data: pd.DataFrame) -> pd.DataFrame:
        """
        Return feature DataFrame aligned with windowed labels.
        The label column is removed.
        """
        self._validate_label_column(feature_data)

        if len(feature_data) <= self.window_size:
            raise ValueError("Feature data must have more rows than window_size.")

        aligned_features = feature_data.iloc[self.window_size:].drop(
            columns=[self.label_column]
        )

        return aligned_features

    def build_xy(self, labeled_df: pd.DataFrame) -> tuple[pd.DataFrame, np.ndarray]:
        aligned_features: pd.DataFrame = self.get_aligned_features(labeled_df)
        aligned_labels: np.ndarray = self.get_window_aligned_labels(labeled_df)
        return aligned_features, aligned_labels

    def _future_trend(self, feature: pd.Series, periods: int) -> pd.Series:
        """
        Compute binary trend labels based on future movement.

        feature : pd.Series Time-series target values.
        periods : int Steps ahead to compare for trend labeling.

        returns:  pd. Series Binary trend labels (int8).
        """
        future = feature.shift(-periods)
        trend = (future >= feature).astype(np.int8)
        trend.name = self.label_column
        return trend

    def _align_labels(self, labels: np.ndarray) -> np.ndarray:
        """
        Align labels with feature windows by removing initial rows.

        labels : np.ndarray Original label array.

        returns: Label array aligned with windowed features.
        """
        return labels[self.window_size:]

    def _validate_feature_data(self, feature_data: pd.DataFrame) -> None:
        """
        Validate input DataFrame for required columns and size.
        """
        if self.target_feature not in feature_data.columns:
            raise ValueError(f"Expected '{self.target_feature}' column in input data.")
        if not np.issubdtype(feature_data[self.target_feature].dtype, np.number):
            raise TypeError("Target feature must be numeric.")
        if len(feature_data) <= self.trend_length + self.window_size:
            raise ValueError("Data too small for trend_length + window_size.")


    def _validate_label_column(self, df: pd.DataFrame) -> None:
        """
        Ensure the label column exists in the DataFrame.
        """
        if self.label_column not in df.columns:
            raise ValueError(f"Column '{self.label_column}' not found. Run get_labeled_feature_data() first.")


